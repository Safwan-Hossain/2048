\documentclass[12pt]{article}

\usepackage{graphicx}
\usepackage{paralist}
\usepackage{listings}
\usepackage{booktabs}
\usepackage{hyperref}
\usepackage{amsfonts}
\usepackage{amsmath}

\oddsidemargin 0mm
\evensidemargin 0mm
\textwidth 160mm
\textheight 200mm

\pagestyle {plain}
\pagenumbering{arabic}

\newcounter{stepnum}

\title{Assignment 2 Solution}
\author{Safwan Hossain}
\date{\today}

\begin {document}

\maketitle

This report discusses the testing phase for .... It also discusses the results
of running the same tests on the partner files. The assignment specifications
are then critiqued and the requested discussion questions are answered.

\section{Testing of the Original Program}
	
	I passed 11/15 method cases, which is 24/38 total test cases passed. In my previous test module it said that I passed every case, but there was a small bug in my \textbf{cm()} method where the method was adding instead of multiplying in the inner loop, resulting in a test failure for the methods \textbf{cm()}, \textbf{cm\_x()}, \textbf{cm\_y()} and \textbf{m\_inert()} inside the class BodyT. The test rationale was to test a normal case by using random value, a boundary case (where possible) by using a number really close to the least or greatest allowed number, and an exception test by trying to test the exception directly if there is an exception. Note that my \textbf{Plot.py} did not properly push, but both \textbf{Plot.py} and \textbf{test\_All.py} are now updated.

\section{Results of Testing Partner's Code}
	
	My partner passed all tests in this assignment as well as the previous assignment. As mentioned in the previous section my \textbf{cm()} method was taking the sum of the sum of each element in list 1 and list 2, when it should’ve been taking the sum of the multiplication of each element of the same index between list 1 and list 2.

\section{Critique of Given Design Specification}
	
	The program is consistent with its design, as all naming conventions and ordering of variables are consistent. For example, \textbf{x} and \textbf{y} were used as the names for the variables that represent coordinates of a shape and they were always called first in the respective order (\textbf{x} first, then \textbf{y}, then other variables). The design had excellent essentiality. Only necessary methods were created and there were no methods that could’ve been replaced/used better by an existing method. The design was minimal because all methods focused on a single task and no method did multiple different tasks. The design was also made to be general. \textbf{CircleT} and \textbf{TriangleT} allows for any regular circle or equilateral triangle to be created, while \textbf{BodyT} allows for any irregular shape to be created, which means that \textbf{Scene.py} can be given practically any 2D shape with existing mass and dimensions. The design also leaves room for other shape modules to be added since every module calculates and keeps track of its own properties. The design has high cohesion as all modules within each class relate to one another since they all keep track of their class object’s properties. The design also has low coupling because no modules strongly depend on another module. For example, \textbf{TriangleT}, \textbf{CircleT}, and \textbf{BodyT} only rely on \textbf{Shape.py} for structure and are completely independent otherwise. The interface does not allow the user to check for exceptions because the exceptions in the design must be checked from outside the design. All exceptions are inside constructor methods, which means that if the exception is raised the constructor does not create an object, so the constructor’s class cannot have a method to check if the object does not exist. Although there are no checks for the exceptions, there are errors raised in the console to let the user know that their numbers are invalid. 

\section{Answers}

\begin{enumerate}[a)]

\item 
	I don’t think that testing getters and setter is necessary for small projects. In small projects the implementation would typically be simple and straightforward. If, however the getter or setter have code that does more (e.g. modifying values before setting) than just getting/setting, then they should be unit tested to make sure that the entire code works. Also, when dealing with larger projects, I think that spending a few more minutes to test the getters and setters could potentially save a lot of time because, other methods can return an error if the getter/setter is implemented incorrectly and it may take a while to trace the problem back to the getter and setter.

\item
	The getter method is used to access private properties of a class from outside the class, so a getter for fx and fy can simply return the function like a variable. The functions can be called by the following snippet of code: get\_fx()() or get\_fy()(). The setter methods can be implemented the traditional way, by overwriting the current function with the given function. For example: self.fx = fx.

\item
	

\item
	

\item
	The specification has exceptions for non-positive values of shape dimensions and mass because neither negative mass nor negative dimensions (height, width, length) exist. Also objects with zero mass or zero-dimension values are not considered to exist either; if we were to consider objects with zero mass or dimensional values then it would have no forces acting on it. Coordinates however are relative to a certain point, which means they can be negative because the sign of a coordinate can tell us the direction of a point relative to the coordinate system. 

\item
	The specification ($\neg(s_s > 0 \wedge m_s > 0) \implies$ ValueError) states that if the state invariant is not true, return an error. Let $a = s > 0 \wedge m > 0$, the specification would be $(\neg(a) \implies$ ValueError), which means if $a$ is false, return an error, otherwise do nothing. The variable $a$ can only be false if the state invariant is not satisfied, thus when a triangle is constructed the invariant will always be satisfied.

\item	
roots = [math.sqrt(i) for i in range(5, 20, 2)]

\item
def remove\_upper(string): \\
\hspace*{0.5cm} string2 = "" \\
\hspace*{0.5cm} for i in string: \\
\hspace*{1cm} if not i.isupper(): \\
\hspace*{1.5cm} string2 += str(i) \\
\hspace*{0.5cm} return string2 

\item
Abstraction is the process of focusing on what is important while ignoring what is irrelevant, while generality is solving a more general problem then the one at hand; generality involves reusing a concept for many problems. These two principals are related because you can become more general by using abstraction, as abstraction will only deal with the more important concepts and dismiss less important concepts which makes a concept easier to reuse. 

\end{enumerate}

\newpage

\lstset{language=Python, basicstyle=\tiny, breaklines=true, showspaces=false,
  showstringspaces=false, breakatwhitespace=true}
%\lstset{language=C,linewidth=.94\textwidth,xleftmargin=1.1cm}

\def\thesection{\Alph{section}}

\section{Code for Shape.py}

\noindent \lstinputlisting{../src/Shape.py}

\newpage

\section{Code for CircleT.py}

\noindent \lstinputlisting{../src/CircleT.py}

\newpage

\section{Code for TriangleT.py}

\noindent \lstinputlisting{../src/TriangleT.py}

\newpage

\section{Code for BodyT.py}

\noindent \lstinputlisting{../src/BodyT.py}

\newpage

\section{Code for Scene.py}

\noindent \lstinputlisting{../src/Scene.py}

\newpage

\section{Code for Plot.py}

\noindent \lstinputlisting{../src/Plot.py}

\newpage

\section{Code for test\_All.py}

\noindent \lstinputlisting{../src/test_All.py}

\newpage

\section{Code for Partner's CircleT.py}

\noindent \lstinputlisting{../partner/CircleT.py}

\newpage

\section{Code for Partner's TriangleT.py}

\noindent \lstinputlisting{../partner/TriangleT.py}

\newpage

\section{Code for Partner's BodyT.py}

\noindent \lstinputlisting{../partner/BodyT.py}

\newpage

\section{Code for Partner's Scene.py}

\noindent \lstinputlisting{../partner/Scene.py}

\newpage

\end {document}
